#!/usr/bin/env python3
"""
Amalgamate NotoriousFFT module headers into a single notorious_fft.h (SQLite-style).

Each module file is wrapped in a per-file include guard
  #ifndef NOTORIOUS_FFT_FOO_H / #define NOTORIOUS_FFT_FOO_H / #endif /* NOTORIOUS_FFT_FOO_H */
and may have intra-module dependency includes (#include "NN_module.h").

This script strips those and concatenates everything under one outer guard.
"""

import re
import sys
from pathlib import Path

MODULES = [
    "01_core.h",
    "02_math.h",
    "03_simd.h",
    "04_kernels.h",
    "05_algorithms.h",
    "06_plan.h",
    "07_legacy.h",
]

HEADER = """\
/*
 * notorious_fft.h — Lil' FFT amalgamated single-header library
 *
 * Generated by amalgamate.py — DO NOT EDIT DIRECTLY.
 * Edit the module files in src/ and re-run CMake.
 *
 * Features:
 *   - Hardcoded kernels for N ≤ 64
 *   - Bluestein algorithm for arbitrary-size support
 *   - SIMD acceleration: NEON (AArch64/ARM), AVX2, AVX-512 (x86-64)
 *   - OpenMP parallelisation
 *   - minfft-compatible API (notorious_fft_ prefix)
 *
 * Usage (C):
 *   #define NOTORIOUS_FFT_IMPLEMENTATION
 *   #include "notorious_fft.h"
 *
 * Usage (C++):
 *   #define NOTORIOUS_FFT_IMPLEMENTATION
 *   #include "notorious_fft.h"   // or use the notorious_fft.hpp C++ wrapper
 *
 * Options (define before including):
 *   NOTORIOUS_FFT_SINGLE    — use float instead of double
 *   NOTORIOUS_FFT_FAST_MATH — enable fast Bhaskara I sin/cos approximation (~0.1% error)
 *   NOTORIOUS_FFT_OPENMP    — enable OpenMP (requires -fopenmp)
 *
 * License: MIT
 */

#ifndef NOTORIOUS_FFT_H
#define NOTORIOUS_FFT_H

#ifdef __cplusplus
extern "C" {
#endif

"""

FOOTER = """
#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* NOTORIOUS_FFT_H */
"""

# Strip the per-module include guard lines and intra-module #includes.
# These are the only things that need stripping; the modules themselves don't
# carry extern "C" wrappers (they rely on the amalgam's outer wrapper).
RE_GUARD_IFNDEF  = re.compile(r'^\s*#\s*ifndef\s+NOTORIOUS_FFT_\w+_H\s*$')
RE_GUARD_DEFINE  = re.compile(r'^\s*#\s*define\s+NOTORIOUS_FFT_\w+_H\s*$')
RE_GUARD_ENDIF   = re.compile(r'^\s*#\s*endif\s*/\*\s*NOTORIOUS_FFT_\w+_H\b')
RE_LOCAL_INCLUDE = re.compile(r'^\s*#\s*include\s+"[0-9]+_\w+\.h"\s*$')


def strip_module(path: Path) -> str:
    lines = path.read_text().splitlines()
    out = []
    for line in lines:
        if (RE_GUARD_IFNDEF.match(line) or
                RE_GUARD_DEFINE.match(line) or
                RE_GUARD_ENDIF.match(line) or
                RE_LOCAL_INCLUDE.match(line)):
            continue
        out.append(line)
    # Trim leading/trailing blank lines
    while out and out[0].strip() == '':
        out.pop(0)
    while out and out[-1].strip() == '':
        out.pop()
    return '\n'.join(out)


def main():
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <modules_dir> <output_file>")
        sys.exit(1)

    modules_dir = Path(sys.argv[1])
    output      = Path(sys.argv[2])

    parts = [HEADER]
    for name in MODULES:
        path = modules_dir / name
        if not path.exists():
            print(f"ERROR: module not found: {path}", file=sys.stderr)
            sys.exit(1)
        content = strip_module(path)
        sep = f"\n/* {'='*74}\n * {name}\n * {'='*74} */\n\n"
        parts.append(sep)
        parts.append(content)
        parts.append('\n')

    parts.append(FOOTER)
    output.write_text(''.join(parts))
    print(f"Generated {output}  ({output.stat().st_size} bytes, "
          f"{output.read_text().count(chr(10))} lines)")


if __name__ == "__main__":
    main()
